{"ast":null,"code":"export function findFood(creatures, foods) {\n  creatures.current.forEach((creature, index) => {\n    if (!creature.isFoodFound && creature.canEatFood) {\n      for (let i = 0; i < foods.current.length; i++) {\n        const food = foods.current[i];\n\n        if (food.pos.subtr(creature.pos).mag() < creature.smellRange) {\n          creature.updateFoodFound(food.pos, food.id);\n          break;\n        }\n      }\n    } else {\n      if (creature.isFoodFound && creature.canEatFood && creature.pos.subtr(creature.foundFoodPosition).mag() < creature.sightRange) {\n        let foodIndex = -1;\n\n        for (var i = 0; i < foods.current.length; i++) {\n          if (foods.current[i].id.localeCompare(creature.foodId) === 0) {\n            foodIndex = i;\n            break;\n          }\n        }\n\n        if (foodIndex !== -1) {\n          foods.current.splice(foodIndex, 1);\n          creature.updateFoodEaten();\n          creature.updateLastFoodTime();\n        }\n      }\n    }\n  });\n}","map":{"version":3,"sources":["E:/projects/Fun/genetic algorithm/src/components/gaFunctions/survival.js"],"names":["findFood","creatures","foods","current","forEach","creature","index","isFoodFound","canEatFood","i","length","food","pos","subtr","mag","smellRange","updateFoodFound","id","foundFoodPosition","sightRange","foodIndex","localeCompare","foodId","splice","updateFoodEaten","updateLastFoodTime"],"mappings":"AAAA,OAAO,SAASA,QAAT,CAAkBC,SAAlB,EAA6BC,KAA7B,EAAoC;AACzCD,EAAAA,SAAS,CAACE,OAAV,CAAkBC,OAAlB,CAA0B,CAACC,QAAD,EAAWC,KAAX,KAAqB;AAC7C,QAAI,CAACD,QAAQ,CAACE,WAAV,IAAyBF,QAAQ,CAACG,UAAtC,EAAkD;AAChD,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,KAAK,CAACC,OAAN,CAAcO,MAAlC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7C,cAAME,IAAI,GAAGT,KAAK,CAACC,OAAN,CAAcM,CAAd,CAAb;;AACA,YAAIE,IAAI,CAACC,GAAL,CAASC,KAAT,CAAeR,QAAQ,CAACO,GAAxB,EAA6BE,GAA7B,KAAqCT,QAAQ,CAACU,UAAlD,EAA8D;AAC5DV,UAAAA,QAAQ,CAACW,eAAT,CAAyBL,IAAI,CAACC,GAA9B,EAAmCD,IAAI,CAACM,EAAxC;AACA;AACD;AACF;AACF,KARD,MAQO;AACL,UACEZ,QAAQ,CAACE,WAAT,IACAF,QAAQ,CAACG,UADT,IAEAH,QAAQ,CAACO,GAAT,CAAaC,KAAb,CAAmBR,QAAQ,CAACa,iBAA5B,EAA+CJ,GAA/C,KACET,QAAQ,CAACc,UAJb,EAKE;AACA,YAAIC,SAAS,GAAG,CAAC,CAAjB;;AACA,aAAK,IAAIX,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,KAAK,CAACC,OAAN,CAAcO,MAAlC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7C,cAAIP,KAAK,CAACC,OAAN,CAAcM,CAAd,EAAiBQ,EAAjB,CAAoBI,aAApB,CAAkChB,QAAQ,CAACiB,MAA3C,MAAuD,CAA3D,EAA8D;AAC5DF,YAAAA,SAAS,GAAGX,CAAZ;AACA;AACD;AACF;;AACD,YAAIW,SAAS,KAAK,CAAC,CAAnB,EAAsB;AACpBlB,UAAAA,KAAK,CAACC,OAAN,CAAcoB,MAAd,CAAqBH,SAArB,EAAgC,CAAhC;AACAf,UAAAA,QAAQ,CAACmB,eAAT;AACAnB,UAAAA,QAAQ,CAACoB,kBAAT;AACD;AACF;AACF;AACF,GA9BD;AA+BD","sourcesContent":["export function findFood(creatures, foods) {\r\n  creatures.current.forEach((creature, index) => {\r\n    if (!creature.isFoodFound && creature.canEatFood) {\r\n      for (let i = 0; i < foods.current.length; i++) {\r\n        const food = foods.current[i];\r\n        if (food.pos.subtr(creature.pos).mag() < creature.smellRange) {\r\n          creature.updateFoodFound(food.pos, food.id);\r\n          break;\r\n        }\r\n      }\r\n    } else {\r\n      if (\r\n        creature.isFoodFound &&\r\n        creature.canEatFood &&\r\n        creature.pos.subtr(creature.foundFoodPosition).mag() <\r\n          creature.sightRange\r\n      ) {\r\n        let foodIndex = -1;\r\n        for (var i = 0; i < foods.current.length; i++) {\r\n          if (foods.current[i].id.localeCompare(creature.foodId) === 0) {\r\n            foodIndex = i;\r\n            break;\r\n          }\r\n        }\r\n        if (foodIndex !== -1) {\r\n          foods.current.splice(foodIndex, 1);\r\n          creature.updateFoodEaten();\r\n          creature.updateLastFoodTime();\r\n        }\r\n      }\r\n    }\r\n  });\r\n}\r\n"]},"metadata":{},"sourceType":"module"}