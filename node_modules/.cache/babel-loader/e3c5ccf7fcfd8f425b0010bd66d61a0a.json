{"ast":null,"code":"export function findFood(creatures,foods){creatures.current.forEach(function(creature,index){if(!creature.isFoodFound&&creature.canEatFood){for(var _i=0;_i<foods.current.length;_i++){var food=foods.current[_i];if(food.pos.subtr(creature.pos).mag()<creature.smellRange){creature.updateFoodFound(food.pos,food.id);break;}}}else{if(creature.isFoodFound&&creature.canEatFood&&creature.pos.subtr(creature.foundFoodPosition).mag()<creature.sightRange){var foodIndex=-1;for(var i=0;i<foods.current.length;i++){if(foods.current[i].id.localeCompare(creature.foodId)===0){foodIndex=i;break;}}if(foodIndex!==-1){foods.current.splice(foodIndex,1);creature.updateFoodEaten();creature.updateLastFoodTime();}}}});}","map":{"version":3,"sources":["E:/projects/Fun/genetic algorithm/src/components/gaFunctions/survival.js"],"names":["findFood","creatures","foods","current","forEach","creature","index","isFoodFound","canEatFood","i","length","food","pos","subtr","mag","smellRange","updateFoodFound","id","foundFoodPosition","sightRange","foodIndex","localeCompare","foodId","splice","updateFoodEaten","updateLastFoodTime"],"mappings":"AAAA,MAAO,SAASA,CAAAA,QAAT,CAAkBC,SAAlB,CAA6BC,KAA7B,CAAoC,CACzCD,SAAS,CAACE,OAAV,CAAkBC,OAAlB,CAA0B,SAACC,QAAD,CAAWC,KAAX,CAAqB,CAC7C,GAAI,CAACD,QAAQ,CAACE,WAAV,EAAyBF,QAAQ,CAACG,UAAtC,CAAkD,CAChD,IAAK,GAAIC,CAAAA,EAAC,CAAG,CAAb,CAAgBA,EAAC,CAAGP,KAAK,CAACC,OAAN,CAAcO,MAAlC,CAA0CD,EAAC,EAA3C,CAA+C,CAC7C,GAAME,CAAAA,IAAI,CAAGT,KAAK,CAACC,OAAN,CAAcM,EAAd,CAAb,CACA,GAAIE,IAAI,CAACC,GAAL,CAASC,KAAT,CAAeR,QAAQ,CAACO,GAAxB,EAA6BE,GAA7B,GAAqCT,QAAQ,CAACU,UAAlD,CAA8D,CAC5DV,QAAQ,CAACW,eAAT,CAAyBL,IAAI,CAACC,GAA9B,CAAmCD,IAAI,CAACM,EAAxC,EACA,MACD,CACF,CACF,CARD,IAQO,CACL,GACEZ,QAAQ,CAACE,WAAT,EACAF,QAAQ,CAACG,UADT,EAEAH,QAAQ,CAACO,GAAT,CAAaC,KAAb,CAAmBR,QAAQ,CAACa,iBAA5B,EAA+CJ,GAA/C,GACET,QAAQ,CAACc,UAJb,CAKE,CACA,GAAIC,CAAAA,SAAS,CAAG,CAAC,CAAjB,CACA,IAAK,GAAIX,CAAAA,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGP,KAAK,CAACC,OAAN,CAAcO,MAAlC,CAA0CD,CAAC,EAA3C,CAA+C,CAC7C,GAAIP,KAAK,CAACC,OAAN,CAAcM,CAAd,EAAiBQ,EAAjB,CAAoBI,aAApB,CAAkChB,QAAQ,CAACiB,MAA3C,IAAuD,CAA3D,CAA8D,CAC5DF,SAAS,CAAGX,CAAZ,CACA,MACD,CACF,CACD,GAAIW,SAAS,GAAK,CAAC,CAAnB,CAAsB,CACpBlB,KAAK,CAACC,OAAN,CAAcoB,MAAd,CAAqBH,SAArB,CAAgC,CAAhC,EACAf,QAAQ,CAACmB,eAAT,GACAnB,QAAQ,CAACoB,kBAAT,GACD,CACF,CACF,CACF,CA9BD,EA+BD","sourcesContent":["export function findFood(creatures, foods) {\r\n  creatures.current.forEach((creature, index) => {\r\n    if (!creature.isFoodFound && creature.canEatFood) {\r\n      for (let i = 0; i < foods.current.length; i++) {\r\n        const food = foods.current[i];\r\n        if (food.pos.subtr(creature.pos).mag() < creature.smellRange) {\r\n          creature.updateFoodFound(food.pos, food.id);\r\n          break;\r\n        }\r\n      }\r\n    } else {\r\n      if (\r\n        creature.isFoodFound &&\r\n        creature.canEatFood &&\r\n        creature.pos.subtr(creature.foundFoodPosition).mag() <\r\n          creature.sightRange\r\n      ) {\r\n        let foodIndex = -1;\r\n        for (var i = 0; i < foods.current.length; i++) {\r\n          if (foods.current[i].id.localeCompare(creature.foodId) === 0) {\r\n            foodIndex = i;\r\n            break;\r\n          }\r\n        }\r\n        if (foodIndex !== -1) {\r\n          foods.current.splice(foodIndex, 1);\r\n          creature.updateFoodEaten();\r\n          creature.updateLastFoodTime();\r\n        }\r\n      }\r\n    }\r\n  });\r\n}\r\n"]},"metadata":{},"sourceType":"module"}